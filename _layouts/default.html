
<!DOCTYPE html lang="en">
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>{%if page.debug %}{{ page.title }} (debug){% else %}{{ page.title }}{% endif %}</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <script src="script/modernizr-2.6.2.min.js"></script>
		
		{% if page.debug %}
			<link rel="stylesheet/less" type="text/css" href="style/style.less" />
		{% else %}
			<link rel="stylesheet" type="text/css" href="style/style.css" />
		{% endif %}
		
		<script>
		var _ = (function(window){
			return {
				/**
				 * get element by id
				 */
				gid: function(x) {
					// if _.gid(...) below returned null or nothing was passed, return null
					if (!x) { 
						return null;
					}
					
					if (_.isS(x)) {
						return _.gid(document.getElementById(x));
					}
					
					// check if is already an object run through x
					// if ("function" != typeof(x._)) {
					//
					// 	// allows enriching elements
					// 	x._ = function(){};
					// }
					
					return x;
				},
				/**
				 * Add event listener to window
				 */
				ael: function(args){
					if(window.addEventListener) {
						window.addEventListener.apply(window, arguments);
					} else {
						window.attachEvent.apply(window, arguments);
					}
				},

				/**
				 * returns the dimensions of the viewport
				 */
				dvp: function() {
					var w=window,d=document,e=d.documentElement,g=d.getElementsByTagName('body')[0],
					    x=w.innerWidth||e.clientWidth||g.clientWidth,
						y=w.innerHeight||e.clientHeight||g.clientHeight;
					return {w:x, h:y}
				},
				
				/**
				 * returns the current scroll position;
				 * Creates a function that provides best support without checking each time called
				 */
				scp: (function(){
					
					// find best support
					// from https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
					var isCSS1Compat = ((document.compatMode || "") === "CSS1Compat");
					if ("undefined" != typeof(window.pageYOffset)) {
						return function() { 
							return {
								top: window.pageYOffset,
								left: window.pageXOffset
							}
						}
					}
					
					if (isCSS1Compat) {
						return function() {
							return {
								top: document.documentElement.scrollLeft,
								left: document.documentElement.scrollTop
							}
						}
					}
					
					return function() {
						return {
							top: document.body.scrollLeft,
							left: document.body.scrollTop
						};
					}
				})(),
				
				/**
				 * compute absolute position in browser viewport
				 */			
				offset : function(el) {
				    var top = 0, left = 0, el = _.gid(el);
				    do {
				        top += el.offsetTop  || 0;
				        left += el.offsetLeft || 0;
				        el = el.offsetParent;
				    } while(el);

				    return {
				        top: top,
				        left: left
				    };
				},
				
				/**
				 * is number
				 */
				isN: function(x){
					return "number" == typeof(x);
				},
				
				/**
				 * make an array form a dom list
				 */
				toA: function(dl) {
					if (!dl) {
						return [];
					}
					return Array.prototype.map.call(dl, function(e){return e});
				},
				
				/**
				 * isString -- only works if an object is passed!
				 */
				isS: function(x) {
					return "function" == typeof(x.substr);
				},
				
				/**
				 * resizes a text (font-size) by the width 
				 * of its parent element or ratio of viewport width 
				 */
				fit: function(el, options) {
					var options = options || {},
						min = (_.isN(options.min) ? options.min : 0), // minimum font size
						max = (_.isN(options.max) ? options.max : Infinity), // maximum font size
						f = (_.isN(options.f) ? options.f : 1), // scale factor						
						w = (_.isN(options.w) ? options.w : false); // ratio of width of page (widht of parent element will be used if 0 or undefined)
						
					var c = function() {
						var e = _.gid(el),
						    s = Math.max(Math.min((w ? _.dvp().w*w : e.clientWidth) / (f*10), 
												parseFloat(max)), 
													parseFloat(min)) + 'px';
						e.style.fontSize = s;
      				}
					
					_.ael("resize", c);
					_.ael("orientationchange", c);
					c();
				},
				
				encode: function (string){
					return string.split("").map(function(i){return (i.charCodeAt(0)+13)}).join("|");

				},

				decode: function (string) {
					return string.split("|").map(function(i){return String.fromCharCode(parseInt(i) - 13)}).join("");
				}
			}
		})(window);
		
		/**********************************************************************
		 * run if visible
		 * calls fn, if el is visible in the browser's viewport
		 * repeat number of times the function shall be called, pass Infinity if required
		 * ensure correct scope in fn
		 */
		var runIfVisible = (function(){
			var riv = function(el, fn, repeat) {
				riv.r.push({
					el: el,
					fn: fn,
					rp: repeat || !!repeat,
					top: _.offset(el).top,
					bot: _.offset(el).top + el.offsetHeight
				});
			};
			
			var vph = _.dvp().h;
			
			// store registrations
			riv.r = [];
			
			// recompute values
			riv.update = function(){
				riv.r.forEach(function(r) {
					r.top = _.offset(r.el).top;
					r.bot = r.top + r.el.offsetHeight;
				});
				
				vph = _.dvp().h;
			}
			
			// register events for recomputation
			_.ael("load", riv.update);
			_.ael("resize", riv.update);
			_.ael("orientationchange", riv.update);
			
			function show() {
				var stop = _.scp().top;
				// start showing if elements are visible 
				
				var ub = stop + .1 * vph, // 10% from the top edge of viewport
				    lb = stop + .75 * vph, // 25% from bottom edge of viewport
					rm = [];
				
				// iterate over elements
				for (var i=0; i < riv.r.length; i++) {
					var r = riv.r[i];
					if (!r.d && r.bot > ub && r.top < lb) {
						r.fn(r.el);
						
						// disable registration as it has been shown
						r.d = true;
						
						if (!r.rp || (--r.rp < 1)) { 
							// remove registrations
							riv.r.splice(i,1);
							i--;
						}
					}
					
					// reenable after it vanished from the viewport
					if (r.d && (r.top > stop + vph || r.top < stop)) {
						r.d = false;
					}
				}
			}
			
			// call action on scroll
			_.ael("scroll", show);
			_.ael("load", show);
			
			return riv;
		})();
		
		</script>

    </head>
    <body>
		<!--[if lt IE 9]>
		  <script>
		    document.createElement("header" );
		    document.createElement("footer" );
		    document.createElement("section"); 
		    document.createElement("aside"  );
		    document.createElement("nav"    );
		    document.createElement("article"); 
		    document.createElement("hgroup" ); 
		    document.createElement("time"   );
		  </script>
		  <noscript>
		     <strong>Warning!</strong>
		     Because your browser does not support HTML5, some elements are simulated using JScript.
		     Unfortunately your browser has disabled scripting. Please enable it in order to display this page.
		  </noscript>
		<![endif]-->
	
		<section id="teaser" data-pagetitle="Matthias Kunze | BPM Expert · IT Enginer">{% include teaser.html%}</section>
		<section id="aboutme" data-pagetitle="About me">{% include aboutme.html%}</section>
		
		<script>
			// this avoids constant resizing on touch devices that hide/show
			// the address bar when scrolling
			(function(){
				if(Modernizr.touch) {
					_.ael("load", function(){
						var t = _.gid("teaser");
						t.style.height = Math.min(_.dvp().h, parseInt(window.getComputedStyle(t).height)) + "px";
					});
				}
			})()
		</script>
		
		<div class="parallax" id="hireme" data-pagetitle="Hire me">
			<div class="parallax-back"></div>
			<section class="parallax-base">{% include hireme.html%}</section>
		</div>
		
		<div class="parallax" id="curriculum" data-pagetitle="Curriculum">
			<div class="parallax-back"></div>
			<section class="parallax-base">{% include curriculum.html%}</section>
		</div>
		
		<div class="parallax" id="projects" data-pagetitle="Projects">
			<div class="parallax-back"></div>
			<section class="parallax-base">{% include projects.html%}</section>
		</div>
		
		{% include contact.html %}
		
		{% include footer.html %}
		
		<script>
		if (document.querySelectorAll && !Modernizr.touch && runIfVisible) {
			document.body.className = document.body.className + " riv";

			_.toA(document.querySelectorAll("section.parallax-base .title")).forEach(function(t){
				runIfVisible(t, function(t){t.className = t.className + " riv"});
			});
			
			_.toA(document.querySelectorAll("section")).concat(
			_.toA(document.querySelectorAll("div"))).forEach(
				function(s){
					if (s.dataset["pagetitle"]) {			
						runIfVisible(s, function(s){
							window.document.title = s.dataset["pagetitle"];
						}, Infinity);
					}
				}
			);
		}
		</script>
		
		<script>
		var w = 0.5, min = 50, max = 120, 
			rs = 4/2.3, rh = 4/1.8;
		
		// fit all section titles
		_.toA(document.querySelectorAll("section h1.title")).forEach(function(t) {
			if (t.id != "matthias") {
				_.fit(t, {w: w, min: min, max:max});  
			} else {
				_.fit(t, {w: w, min: 33, max:max});  
			}
		});
		
		</script>
	
		<script>
		/**
		 * enable parallax effect for all fragments of following structure
		 *  <x class="parallax">
		 *    <y class="parallax-back"></y>
		 *    <z class="parallax-base"></z>
		 *  </x>
		 */
		
		_.ael("load", (function() {

			// abort if not supported or if it is possible that scroll events don't work properly, e.g., on mobile devices which do not redraw during scrolling
			if (!window.getComputedStyle || !document.querySelectorAll || Modernizr.touch) {
				return false;
			}
			
			// use raf if available to sync recalculation and drawing
			var raf = ("function" == typeof(window.requestAnimationFrame) ?
					   window.requestAnimationFrame : function(c){c()});

			var vph = _.dvp().h; // height of browser window;
			
			// find all parallax elements
			var elements = [];
			_.toA(document.querySelectorAll(".parallax")).forEach(function(wrap){
				var back = wrap.querySelector(".parallax-back");
				var base = wrap.querySelector(".parallax-back");
				
				if (base && back) {
					elements.push({
						wrap: wrap,
						base: base,
						back: back
					});
				}
			});
			
			// refresh position of background
			function refresh() {
				var stop = _.scp().top;
				var update = [];
				
				// identify elements that require update and 
				// compute new positions, but do not redraw yet
				elements.forEach(function(e){
					if ( stop + vph > e.top 		  // lower bound of viewport
						&& stop < e.top + e.vp_height // upper bound of viewport
					) {
						// r ... ratio -- relative position of upper bound of
						// wrapper in the vewport, t ... aply to position of
						// background
						var r = 1 + (stop - e.top - e.vp_height) / (vph + e.vp_height);
						var t = r * (e.vp_height - e.os_height);
												
						update.push({el: e.back, top: t});
					}
				});
					
				// draw		
				raf(function(t){
					update.forEach(function(e) {
						e.el.style.top = e.top + "px";
					});
				
					// reset update queue
					update = [];
				});	
				

			}
			
			// recompute position of foreground and background
			function update() {
				elements.forEach(function(e){
					e.os_height = e.back.clientHeight; // scrollHeight?
					e.vp_height = parseInt(window.getComputedStyle(e.wrap).paddingTop)
					e.top = _.offset(e.wrap).top;
				});
				
				vph = _.dvp().h;
				
				refresh();
			}
			
			_.ael("scroll", refresh);
			_.ael("resize", update); // TODO -- onresizeend
			_.ael("orientationchange", update);
			update();
			
		})); // end of _.ael("load", ... ) -- parallax effect
		
		</script>
		


		{% if page.debug %}
		<!-- .............................................................................................................. -->
		<script>
		  less = {
		    env: "development",
			logLevel: 1
		  };
		</script>
		<script src="script/less.js"></script>
		
		<script>
		if (document.location.search.match(/watch/)) {
				console.log("less watches" + (less.watch() ? "" : "not"));
		}
		</script>
		
		<script>
		if (document.location.search.match(/debug/)) {
			// show viewport dimensions
			
			var w=window,
			    d=document,
			    e=d.documentElement,
			    b=d.getElementsByTagName('body')[0];
			
			var p = document.createElement("pre");
			    p.id="debug";
				document.body.appendChild(p);
				
			var c = function() {
				var scp = _.scp();
				
				_.gid("debug").innerHTML = 
					" win:    " + w.innerWidth + " × " + w.innerHeight + "\n" + 
				    " doc:    " + e.clientWidth + " × " + e.clientHeight + "\n" + 
					" body:   " + b.clientWidth + " × " + b.clientHeight + "\n " + 
					" scroll: " + scp.left + " x " + scp.top + "\n "
			};
			_.ael("resize", c);
			_.ael("scroll", c);
			c();
		}
		
		if (document.location.search.match(/validate/)) {
			// some functions to chekc sonsistency of page ********************
			
			// check links
			Array.prototype.forEach.call(document.querySelectorAll("section a"), function(a){
				if (0 == a.childNodes.length || !a.childNodes[0].className || !a.childNodes[0].className.match(/lnk/)) {
					a.title = "missing parent node .lnk";
					a.style.backgroundColor = "red";
				}
			});
			
			// check layout
			Array.prototype.forEach.call(document.querySelectorAll("section > *"), function(e){
				if (-1 == e.className.split(" ").indexOf("inner") && !e.className.match(/title/)) {
					e.appendChild(document.createTextNode("Missing class .inner"));
					e.style.backgroundColor = "red";
				}
			});
			
		}
		
		</script>
		{% endif %}
    </body>
</html>
